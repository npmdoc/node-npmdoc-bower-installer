<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://github.com/rquadling/bower-installer#readme"

    >bower-installer (v1.3.6)</a>
</h1>
<h4>Tool for installing bower dependencies that won't include entire repos</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.bower-installer">module bower-installer</a><ol>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">bower-installer.</span>installer</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">bower-installer.</span>utils</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.bower-installer.installer">module bower-installer.installer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bower-installer.installer.installDependency">
            function <span class="apidocSignatureSpan">bower-installer.installer.</span>installDependency
            <span class="apidocSignatureSpan">(deps, pakcfg, cfg, paths, silent, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bower-installer.installer.removeComponentsDir">
            function <span class="apidocSignatureSpan">bower-installer.installer.</span>removeComponentsDir
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.bower-installer.utils">module bower-installer.utils</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bower-installer.utils.copyFile">
            function <span class="apidocSignatureSpan">bower-installer.utils.</span>copyFile
            <span class="apidocSignatureSpan">(source, target, cb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bower-installer.utils.deleteFolderRecursive">
            function <span class="apidocSignatureSpan">bower-installer.utils.</span>deleteFolderRecursive
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bower-installer.utils.getExtension">
            function <span class="apidocSignatureSpan">bower-installer.utils.</span>getExtension
            <span class="apidocSignatureSpan">(filename)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bower-installer.utils.getJSON">
            function <span class="apidocSignatureSpan">bower-installer.utils.</span>getJSON
            <span class="apidocSignatureSpan">(path, pathSep, filename)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bower-installer.utils.getPathByRegExp">
            function <span class="apidocSignatureSpan">bower-installer.utils.</span>getPathByRegExp
            <span class="apidocSignatureSpan">(filename, paths)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bower-installer.utils.hasVariableInPath">
            function <span class="apidocSignatureSpan">bower-installer.utils.</span>hasVariableInPath
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.bower-installer.utils.parsePath">
            function <span class="apidocSignatureSpan">bower-installer.utils.</span>parsePath
            <span class="apidocSignatureSpan">(path, map)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.bower-installer" id="apidoc.module.bower-installer">module bower-installer</a></h1>





</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.bower-installer.installer" id="apidoc.module.bower-installer.installer">module bower-installer.installer</a></h1>


    <h2>
        <a href="#apidoc.element.bower-installer.installer.installDependency" id="apidoc.element.bower-installer.installer.installDependency">
        function <span class="apidocSignatureSpan">bower-installer.installer.</span>installDependency
        <span class="apidocSignatureSpan">(deps, pakcfg, cfg, paths, silent, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function installDependency(deps, pakcfg, cfg, paths, silent, callback) {
  var base, other;

  var key = pakcfg.key;
  var options = {};
  if (cfg.options) {
    options = cfg.options;
  } else {
    Object.keys(defaultInstallOptions).forEach(function (key) {
      options[key] = defaultInstallOptions[key];
    });
  }

  // Look for an overriden source
  if (cfg.sources &#x26;&#x26; cfg.sources[key]) {
    // local path, so should work
    deps = cfg.sources[key];
  } else {
    deps = deps.split(&#x27;,&#x27;);
  }

  if (deps.options &#x26;&#x26; typeof deps.options === &#x27;object&#x27;) {
    Object.keys(deps.options).forEach(function (key) {
      if (typeof defaultInstallOptions[key] === &#x27;undefined&#x27;) {
        console.warn(&#x22;option &#x22; + key + &#x22; is not a valid install option&#x22;);
      } else {
        options[key] = deps.options[key];
      }
    });
  }

  // Check for mapping which will map old file names to new ones
  if (deps.mapping) {
    deps = deps.mapping;
  }

  // Ensure we always are dealing with an array
  if (!_.isArray(deps)) {
    deps = [deps];
  }

  // Install each dependency
  async.each(deps, function (dep, callback) {

    var src, dest;

    // If the file is an object, it is for mapping (renaming) the source
    // file to a new filename in the destination. Because of this, it
    // does not make sense to do a file glob, just immediately install
    // the file
    if (_.isObject(dep)) {

      // dep is in the form { src : dest }. extrac the key and value.
      for (var dep_key in dep) {
        src = dep_key;
        dest = dep[src];
      }

      // is the input path a glob?
      if (/\*\*/.test(src)) {

        glob(src, function (err, files) {
          if (err) {
            if (!silent) {
              console.log((&#x27;Error globbing \t&#x27; + key + &#x27; : &#x27; + src).red);
              console.log((&#x27;\t\t&#x27; + err).red);
            }
          } else {
            async.each(files, function (f, callback) {
              installFile(f, pakcfg, paths, src, dest, silent, options, callback);
            }, callback);
          }
        });

      } else {
        installFile(dep, pakcfg, paths, dep, &#x27;&#x27;, silent, options, callback);
      }
    } else {
      glob(dep, function (err, files) {
        if (err) {
          if (!silent) {
            console.log((&#x27;Error globbing \t&#x27; + key + &#x27; : &#x27; + dep).red);
            console.log((&#x27;\t\t&#x27; + err).red);
          }
        } else {
          async.each(files, function (f, callback) {
            installFile(f, pakcfg, paths, dep, &#x27;&#x27;, silent, options, callback);
          }, callback);
        }
      });
    }
  }, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  pakcfg = {name: key};
}
pakcfg.key = key;

if (cfg &#x26;&#x26; (!cfg.ignore || (cfg.ignore &#x26;&#x26; !_.includes(cfg.ignore, key)))) {
  if (_.isArray(dep)) {
    async.each(dep, function (subDep, callback) {
      installer.<span class="apidocCodeKeywordSpan">installDependency</span>(subDep, pakcfg, cfg, paths, options.silent, callback
);
    }, callback);
  } else {
    installer.installDependency(dep, pakcfg, cfg, paths, options.silent, callback);
  }
} else {
  if (!options.silent) {
    console.log((&#x27;\tIgnoring: &#x27; + key).yellow);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bower-installer.installer.removeComponentsDir" id="apidoc.element.bower-installer.installer.removeComponentsDir">
        function <span class="apidocSignatureSpan">bower-installer.installer.</span>removeComponentsDir
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeComponentsDir = function (callback) {
  utils.deleteFolderRecursive(basePath + pathSep + &#x27;bower_components&#x27;);
  callback();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    console.error((&#x27;Error:&#x27;).red, err);
  }
} else {
  if (options.remove) {
    if (!options.silent) {
      process.stdout.write(&#x27;Removing bower_components dir...&#x27;);
    }
    installer.<span class="apidocCodeKeywordSpan">removeComponentsDir</span>(function (err) {
      if (!options.silent) {
        if (err) {
          process.stdout.write((&#x22;Error&#x22;).red, err);
        } else {
          process.stdout.write((&#x22;Finished\r\n&#x22;).green);
        }
      }
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.bower-installer.utils" id="apidoc.module.bower-installer.utils">module bower-installer.utils</a></h1>


    <h2>
        <a href="#apidoc.element.bower-installer.utils.copyFile" id="apidoc.element.bower-installer.utils.copyFile">
        function <span class="apidocSignatureSpan">bower-installer.utils.</span>copyFile
        <span class="apidocSignatureSpan">(source, target, cb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function copyFile(source, target, cb) {
  var cbCalled = false;

  var rd = fs.createReadStream(source);
  rd.on(&#x22;error&#x22;, function (err) {
    done(err);
  });
  var wr = fs.createWriteStream(target);
  wr.on(&#x22;error&#x22;, function (err) {
    done(err);
  });
  wr.on(&#x22;close&#x22;, function (ex) {
    done();
  });
  rd.pipe(wr);

  function done(err) {
    if (!cbCalled) {
      cb(err);
      cbCalled = true;
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  } catch (error) {
    // We wont need to show log error, if package.json doesnt exist default to download folder
    // console.log(error);
  }
}

if (!fs.lstatSync(f_name).isDirectory() &#x26;&#x26; f_name !== f_path) {
  utils.<span class="apidocCodeKeywordSpan">copyFile</span>(f_name, f_path, function (error) {
    if (!error) {
      if (!silent) {
        console.log((&#x27;\t&#x27; + key + &#x27; : &#x27; + f_path).green);
      }
    } else {
      if (!silent) {
        console.log((&#x27;Error\t&#x27; + f + &#x27; : &#x27; + f_path).red);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bower-installer.utils.deleteFolderRecursive" id="apidoc.element.bower-installer.utils.deleteFolderRecursive">
        function <span class="apidocSignatureSpan">bower-installer.utils.</span>deleteFolderRecursive
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function deleteFolderRecursive(path) {
  var files = [];
  if (fs.existsSync(path)) {
    files = fs.readdirSync(path);
    files.forEach(function (file, index) {
      var curPath = path + &#x22;/&#x22; + file;
      if (fs.statSync(curPath).isDirectory()) { // recurse
        deleteFolderRecursive(curPath);
      } else { // delete file
        fs.unlinkSync(curPath);
      }
    });
    fs.rmdirSync(path);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
_.each(installPathFiles, function (file) {

  // if file path has variables like {name} do not create/delete folder
  // the folder will be created later in the installer
  if (!utils.hasVariableInPath(file)) {

    if (options[&#x27;remove-install-path&#x27;]) {
      utils.<span class="apidocCodeKeywordSpan">deleteFolderRecursive</span>(file);
    }

    if (!fs.existsSync(file)) {
      fileLib.mkdirSync(file, 0755, true);
    }
  }
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bower-installer.utils.getExtension" id="apidoc.element.bower-installer.utils.getExtension">
        function <span class="apidocSignatureSpan">bower-installer.utils.</span>getExtension
        <span class="apidocSignatureSpan">(filename)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getExtension(filename) {
  return pathLib.extname(filename || &#x27;&#x27;).slice(1);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    path = utils.parsePath(paths.all, pakcfg) + (options.includePackageNameInInstallPath ? pathSep + key : &#x27;&#x27;) + subDir
;

  } else {
    // Determine the path by regular expression...
    path = utils.getPathByRegExp(f_name, paths)
// ...or by file extension.
|| paths[utils.<span class="apidocCodeKeywordSpan">getExtension</span>(f_name)];

    if (path &#x26;&#x26; typeof path !== &#x27;undefined&#x27;) {

if (!utils.hasVariableInPath(path)) {
  path += (options.includePackageNameInInstallPath ? pathSep + key : &#x27;&#x27;) + subDir;
}
else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bower-installer.utils.getJSON" id="apidoc.element.bower-installer.utils.getJSON">
        function <span class="apidocSignatureSpan">bower-installer.utils.</span>getJSON
        <span class="apidocSignatureSpan">(path, pathSep, filename)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getJSON = function (path, pathSep, filename) {
  var pakcfg = null;

  // If it is a directory lets try to read from package.json file
  if (fs.lstatSync(path).isDirectory()) {
    var pakpath = path + pathSep + (filename ? filename : &#x27;bower&#x27;) + &#x27;.json&#x27;;

    // we want the build to continue as default if case something fails
    try {
      // read package.json file
      var file = fs.readFileSync(pakpath).toString(&#x27;ascii&#x27;)

      // parse file
      pakcfg = JSON.parse(file);

    } catch (error) {
    }
  }

  return pakcfg;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  key: key
}
        }), function (o, callback) {
var dep = o.dep,
  key = o.key;

var keypath = basePath + pathSep + bower.config.directory + pathSep + key;
var pakcfg = utils.<span class="apidocCodeKeywordSpan">getJSON</span>(keypath, pathSep);
if (!pakcfg) {
  pakcfg = {name: key};
}
pakcfg.key = key;

if (cfg &#x26;&#x26; (!cfg.ignore || (cfg.ignore &#x26;&#x26; !_.includes(cfg.ignore, key)))) {
  if (_.isArray(dep)) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bower-installer.utils.getPathByRegExp" id="apidoc.element.bower-installer.utils.getPathByRegExp">
        function <span class="apidocSignatureSpan">bower-installer.utils.</span>getPathByRegExp
        <span class="apidocSignatureSpan">(filename, paths)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getPathByRegExp(filename, paths) {
  for (var key in paths) {
    if (!paths.hasOwnProperty(key)) {
      continue;
    }

    if (key.indexOf(&#x22;/&#x22;) === 0
      &#x26;&#x26; key.lastIndexOf(&#x22;/&#x22;) &#x3e; 0) {
      // Assume the key is a RegExp formatted string.
      var regExp = new RegExp(key.substring(1, key.lastIndexOf(&#x22;/&#x22;)));
      if (filename.match(regExp)) {
        return paths[key];
      }
    }
  }

  return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // If the configured paths is a map, use the path for the given file extension
  if (paths.all) {

    path = utils.parsePath(paths.all, pakcfg) + (options.includePackageNameInInstallPath ? pathSep + key : &#x27;&#x27;) + subDir
;

  } else {
    // Determine the path by regular expression...
    path = utils.<span class="apidocCodeKeywordSpan">getPathByRegExp</span>(f_name, paths)
// ...or by file extension.
|| paths[utils.getExtension(f_name)];

    if (path &#x26;&#x26; typeof path !== &#x27;undefined&#x27;) {

if (!utils.hasVariableInPath(path)) {
  path += (options.includePackageNameInInstallPath ? pathSep + key : &#x27;&#x27;) + subDir;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bower-installer.utils.hasVariableInPath" id="apidoc.element.bower-installer.utils.hasVariableInPath">
        function <span class="apidocSignatureSpan">bower-installer.utils.</span>hasVariableInPath
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hasVariableInPath = function (path) {
  return path.indexOf(&#x27;{&#x27;) !== -1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      function (path) {
return (basePath + pathSep + path);
      });
    _.each(installPathFiles, function (file) {

      // if file path has variables like {name} do not create/delete folder
      // the folder will be created later in the installer
      if (!utils.<span class="apidocCodeKeywordSpan">hasVariableInPath</span>(file)) {

if (options[&#x27;remove-install-path&#x27;]) {
  utils.deleteFolderRecursive(file);
}

if (!fs.existsSync(file)) {
  fileLib.mkdirSync(file, 0755, true);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.bower-installer.utils.parsePath" id="apidoc.element.bower-installer.utils.parsePath">
        function <span class="apidocSignatureSpan">bower-installer.utils.</span>parsePath
        <span class="apidocSignatureSpan">(path, map)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parsePath = function (path, map) {
  if (path.indexOf(&#x27;{&#x27;) !== -1) {

    var keys = path.match(KEYS_MATCH);

    _.each(keys, function (key) {
      var p = key.match(KEY_NAME);
      key = p[1];

      var val = key in map ? map[key] : &#x27;&#x27;;
      path = path.replace(new RegExp(&#x27;\\{[ ]?&#x27; + key + &#x27;[ ]?\\}&#x27;, &#x27;gi&#x27;), val);

    });
  }
  return path;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (infixDir != &#x27;&#x27;) {
  subDir = pathSep + infixDir + subDir;
}

// If the configured paths is a map, use the path for the given file extension
if (paths.all) {

  path = utils.<span class="apidocCodeKeywordSpan">parsePath</span>(paths.all, pakcfg) + (options.includePackageNameInInstallPath
 ? pathSep + key : &#x27;&#x27;) + subDir;

} else {
  // Determine the path by regular expression...
  path = utils.getPathByRegExp(f_name, paths)
    // ...or by file extension.
    || paths[utils.getExtension(f_name)];
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
